This document assumes that multiple AcquiSuites are configured to upload to
the same server.

When a 2-meter setup is detected (for solar, load and utility), only 2 of the
3 meters are specified in the settings screen (to be added), the missing
meter can be calculated using the following formulas:


utility meter readings = load meter readings - solar meter readings

load meter readings = solar meter readings + utility meter readings

solar meter readings = load meter readings - utility meter readings


A possible solution would be the following:

-= MongoDB Changes =-

In Customer class ...

Change the following fields to mongodb.StringField():

facility
solar

Add the following fields:

load = mongodb.StringField()
logger_serial_number = mongodb.StringField()
logger_password = mongodb.StringField()

-= Settings page =-

Add fields to store data for the following in the Customer fields above.

serial number (AcquiSuite) => stored in logger_serial_number
password (AcquiSuite) => stored in logger_password
facility (meter ID) => stored in facility
load (meter ID) => stored in load
solar (meter ID) => stored in solar

-= consume.py view changes =-

Each AcquiSuite transmits form variables for the serial number and the password
along with the gzipped log data.

When building the data structure to save to influxdb, the value of the 'name'
key should be a string combining '<serial number>_<meter ID>' where
<serial number> comes from the form variable request.form['SERIALNUMBER'] and
<meter ID> comes from the meter id embedded in the log file name. Within
consume.py, the meter ID is already extracted and stored in a variable called
device_address
To prevent an unauthorized AcquiSuite from transmitting data to the server,
along with the serial number, the password obtained from the form variable
request.form('PASSWORD') must match what is defined in the Cenergy Insights'
settings page (fields to be added at some point).

-= overall changes =-

There is a module called meter_settings.py which contains the hardcoded meter
IDs in use now. This needs to be removed and every file relying on this module
changed. Celery tasks and flask views should obtain the meter IDs from mongodb.

All of the existing celery tasks need to be altered to work with the meters for
all customers. For each celery task in tasks.py, the meter ID parameter(s) should
be removed as well as the enties in settings.py then add code to each task to
query Customers within mongodb to get the meter IDs in '<serial number>_<meter ID>'
format to use where <serial_number> is the logger_serial_number field and
<meter_id> can be the facility, load or solar field which ever is needed for the
task to work.

What I cannot describe are the changes needed on the front-end.

Finally there is the celery task to compute the readings for the missing meter.

-= New celery task =-

#
# WARNING !!! PSEUDO CODE BELOW !!!
#
@celery.task(name='tasks.one.minute.compute.missing.meter')
def compute_missing_meter():
    customers = db.Customer.object()
    for customer in customers:
        solar_meter_missing = False
        load_meter_missing = False
        utility_meter_missing = False

        # find missing meter
        if len(customer.solar.strip()) == 0:
            solar_meter_missing = True
        if len(customer.load.strip()) == 0:
            load_meter_missing = True
        if len(customer.utility.strip()) == 0:
            utility_meter_missing = True
    
        if not solar_meter_missing and not load_meter_missing and not utility_meter_missing:
            # This customer has all three meters defined so proceed with the next customer
            continue
        
        data = {'name': customer.logger_serial_number + '_missing_meter'), 'columns': ['time', 'P', 'L1_PF', 'L1_V'], 'points': []}

        if solar_meter_missing:
        
            load_query = 'select * from "%s" where time > now() - 1m;' % (customer.logger_serial_number + '_' + customer.load, )
            load_result = influxdb.query(load_query)
            load_points = [record for record in load_result]

            utility_query = 'select * from "%s" where time > now() - 1m;' % (customer.logger_serial_number + '_' + customer.utility, )
            utility_result = influxdb.query(utility_query)
            utility_points = [record for record in utility_result]

            print 'number of load ', len(load_points), 'number of utility ', ĺen(utility_points)

            # TODO: solar meter readings = load meter readings - utility meter readings
            for i, reading in enumerate(load_points):
                computed_timestamp = reading[0]
                power = float(reading[1]) - float(utility_points[i][1]) # data point "Total Net Instantaneous Real Power"
                power_factor = float(reading[2]) - float(utility_points[i][2]) # data point "Total Power Factor"
                voltage = float(reading[3]) - float(utility_points[i][3]) # data point "Voltage, Phase A - N"
                point = [computed_timestamp, power, power_factor, voltage]
                data['points'].append(point)            

        if load_meter_missing:
        
            solar_query = 'select * from "%s" where time > now() - 1m;' % (customer.logger_serial_number + '_' + customer.solar, )
            solar_result = influxdb.query(solar_query)
            solar_points = [record for record in solar_result]

            utility_query = 'select * from "%s" where time > now() - 1m;' % (customer.logger_serial_number + '_' + customer.utility, )
            utility_result = influxdb.query(utility_query)
            utility_points = [record for record in utility_result]

            print 'number of solar ', len(solar_points), 'number of utility ', ĺen(utility_points)

            # TODO: load meter readings = solar meter readings + utility meter readings
            for i, reading in enumerate(solar_points):
                computed_timestamp = reading[0]
                power = float(reading[1]) + float(utility_points[i][1]) # data point "Total Net Instantaneous Real Power"
                power_factor = float(reading[2]) + float(utility_points[i][2]) # data point "Total Power Factor"
                voltage = float(reading[3]) + float(utility_points[i][3]) # data point "Voltage, Phase A - N"
                point = [computed_timestamp, power, power_factor, voltage]
                data['points'].append(point)            

        if utility_meter_missing:
        
            load_query = 'select * from "%s" where time > now() - 1m;' % (customer.logger_serial_number + '_' + customer.load, )
            load_result = influxdb.query(load_query)
            load_points = [record for record in load_result]

            solar_query = 'select * from "%s" where time > now() - 1m;' % (customer.logger_serial_number + '_' + customer.solar, )
            solar_result = influxdb.query(solar_query)
            solar_points = [record for record in solar_result]

            print 'number of load ', len(load_points), 'number of solar ', ĺen(solar_points)

            # TODO: utility meter readings = load meter readings - solar meter readings
            for i, reading in enumerate(load_points):
                computed_timestamp = reading[0]
                power = float(reading[1]) - float(solar_points[i][1]) # data point "Total Net Instantaneous Real Power"
                power_factor = float(reading[2]) - float(solar_points[i][2]) # data point "Total Power Factor"
                voltage = float(reading[3]) - float(solar_points[i][3]) # data point "Voltage, Phase A - N"
                point = [computed_timestamp, power, power_factor, voltage]
                data['points'].append(point)            

        # NOTE: Only write to the database if there are points computed for the missing meter
        if len(data['points']) > 0:
            influxdb.write_points([data])
